# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x6HIsKeNY5KnIuFMmanhbzyMA1HqyEi6
"""

# app.py - C√ìDIGO ADAPTADO PARA STREAMLIT
import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap

# --- Fun√ß√µes e Bases de Dados (sem altera√ß√µes do seu c√≥digo original) ---
def planck(wavelength_nm, T_kelvin):
    h = 6.626e-34; c = 3.0e8; k = 1.38e-23; wav_m = wavelength_nm * 1e-9
    intensity = (2*h*c**2) / (wav_m**5 * (np.exp((h*c)/(wav_m*k*T_kelvin)) - 1))
    return np.nan_to_num(intensity)

def calcular_pico_wien(T_kelvin):
    b = 2.898e-3; lambda_max_m = b / T_kelvin
    return lambda_max_m * 1e9

# Dicion√°rios de dados (LINHAS_ATLAS, PARAMETROS_INTENSIDADE) s√£o os mesmos
LINHAS_ATLAS = {
    "Si IV": {"linhas": [408.9, 411.6]}, "He II": {"linhas": [468.6, 541.2]},
    "Si III": {"linhas": [455.3, 456.8]}, "He I": {"linhas": [447.1, 587.6, 667.8]},
    "Mg II": {"linhas": [448.1]}, "Si II": {"linhas": [634.7, 637.1]},
    "H": {"linhas": [410.2, 434.1, 486.1, 656.3]},
    "Ca II": {"linhas": [393.4, 396.8]}, "Fe II": {"linhas": [492.4, 501.8, 516.9]},
    "Fe I": {"linhas": [438.4, 527.0, 532.8]}, "Ca I": {"linhas": [422.7, 612.2, 616.2]},
    "TiO": {"linhas": [615.9, 705.5]}
}
PARAMETROS_INTENSIDADE = {
    "H":      (9600, 7000), "Ca II":  (5200, 6000), "He I":   (22000, 5000),
    "Fe II":  (7500, 4000), "Si III": (28000, 3500), "Mg II":  (12000, 3000),
    "Si II":  (14000, 3000), "He II":  (33000, 2500), "Si IV":  (40000, 2500),
    "Fe I":   (4800, 2000), "Ca I":   (4200, 1500), "TiO":    (3200, 1000)
}

def get_classe_espectral(temp):
    if temp >= 30000: return "O"
    if temp >= 10000: return "B"
    if temp >= 7500: return "A"
    if temp >= 6000: return "F"
    if temp >= 5200: return "G"
    if temp >= 3700: return "K"
    return "M"

# --- Interface Streamlit ---
st.set_page_config(page_title="Simulador de Espectros", layout="wide", page_icon="üî≠")
st.title("üî≠ Simulador Interativo de Espectros Estelares")

# Controles na barra lateral
with st.sidebar:
    st.header("Par√¢metros da Estrela")
    temperatura = st.slider("Temperatura (K)", min_value=2800, max_value=40000, value=5800, step=200)
    log_g = st.slider("Gravidade (log g)", min_value=1.0, max_value=5.0, value=4.5, step=0.1)

    st.header("Intervalo do Gr√°fico")
    x_min, x_max = st.slider("Comprimento de Onda (nm)", 100, 2000, (380, 750))


# --- Fun√ß√£o de Plotagem (adaptada para Streamlit) ---
# A fun√ß√£o principal √© a mesma, apenas a chamada final muda
wavelengths = np.linspace(x_min, x_max, 4000)
classe = get_classe_espectral(temperatura)
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), sharex=True, gridspec_kw={'height_ratios': [1, 1]})
fig.set_facecolor('black')

# Gr√°fico Superior
ax1.set_facecolor('#1e1e1e')
fluxo_continuo = planck(wavelengths, temperatura)
max_visivel = np.max(fluxo_continuo);
if max_visivel == 0: max_visivel = 1
continuo_norm = fluxo_continuo / max_visivel
pico_nm = calcular_pico_wien(temperatura)
grad_wl = np.linspace(380, 700, 500)
grad_img = np.vstack((grad_wl, grad_wl))
cmap = LinearSegmentedColormap.from_list('vis', [(0.0,(0.29,0,0.51)), (0.17,(0,0,1)), (0.33,(0,1,1)), (0.50,(0,1,0)), (0.67,(1,1,0)), (0.83,(1,0.5,0)), (1.0,(1,0,0))])
ax1.imshow(grad_img, aspect='auto', cmap=cmap, extent=[380, 700, -0.05, 1.1])
ax1.plot(wavelengths, continuo_norm, color='white', lw=2)
if wavelengths.min() <= pico_nm <= wavelengths.max():
  ax1.axvline(x=pico_nm, color='gold', linestyle='--', lw=2, label=f'Pico de Wien: {pico_nm:.1f} nm')
ax1.set_title(f'1. Espectro de Corpo Negro para {temperatura} K (Classe {classe})', color='white')
ax1.set_ylabel('Intensidade Relativa', color='white')
ax1.legend(loc='lower left'); ax1.grid(True, alpha=0.2); ax1.tick_params(colors='white'); ax1.set_ylim(-0.05, 1.1)
ax1.set_xlim(x_min, x_max)

# Gr√°fico Inferior
ax2.set_facecolor('#1e1e1e')
fluxo_absorcao = np.ones_like(wavelengths)
largura_base = 0.2 + (log_g - 1.0) * 0.3
for nome, (pico_t, largura_t) in PARAMETROS_INTENSIDADE.items():
    intensidade = np.exp(-((temperatura - pico_t)**2) / (2 * largura_t**2))
    if nome == "TiO":
        intensidade = 1 / (1 + np.exp(0.005 * (temperatura - 3600)))
    if intensidade > 0.05:
        largura_linha = largura_base if nome != "TiO" else 8.0
        for linha_pos in LINHAS_ATLAS[nome]["linhas"]:
            if wavelengths.min() <= linha_pos <= wavelengths.max():
                profundidade = 0.95 * intensidade
                gaussiana = profundidade * np.exp(-((wavelengths - linha_pos)**2) / (2 * largura_linha**2))
                fluxo_absorcao -= gaussiana
ax2.plot(wavelengths, np.clip(fluxo_absorcao, 0, 1), color='white', lw=1.5)
ax2.set_title(f'2. Linhas de Absor√ß√£o para log g = {log_g:.1f}', color='white')
ax2.set_xlabel('Comprimento de Onda (nm)', color='white')
ax2.set_ylabel('Intensidade Normalizada', color='white')
ax2.grid(True, alpha=0.2); ax2.tick_params(colors='white'); ax2.set_ylim(-0.05, 1.1);
ax2.set_xlim(x_min, x_max)
plt.tight_layout()

# MUDAN√áA PRINCIPAL: em vez de plt.show(), usamos st.pyplot()
st.pyplot(fig)

st.info("Este simulador simplifica a f√≠sica estelar para fins educacionais. A largura das linhas de absor√ß√£o √© influenciada pela gravidade superficial (log g), um efeito conhecido como alargamento por press√£o.")